Should be able to prove out various engines using a common set of acceptance tests
  defined in json, maybe?

inputs and outputs are tuples, expressed as arrays.

...so we need to insert


Async by default
  what parts should be async?  tuples() ?  anything else?

=========
[topical!]

http://c2.com/cgi/wiki?RelationalLanguage

It is sad to see SQL being the only widespread data language, as it really adds a lot of mess to the relatively clean conceptual model of relational algebra. The strength of the relational model is its enormously simple data model: in addition to data types (ints, strings, etc.), it only has relations, operators (projection, selection, join, union, sorting, and some others) and integrity constraints.

It would be great to be able to use, in production code, a language where one could say 't' instead of 'select * from t' and 't * t2 [foo = bar]' instead of 'select * from t join t2 on foo=bar'.

In practice since very few would use a multiplication without a filter, I believe they should be combined into a single operator (join). (We can still keep multiplication.) Further, a functional style would be nice so that DBA's could more easily define their own operators without having to add new syntax. A new function that uses two existing functions is not new syntax, just a new function.


=========

from: http://c2.com/cgi/wiki?DatabaseType

I just realized recently that a RelVar is actually an instance of a DatabaseType (or, maybe more specifically, a Table Type)... for example, all variables are instances of a type (for those who think in types). So in fact a relvar is really an instance of some sort of grander type.. or RelType?. The specifications of the RelType? or DatabaseType are the schema, the constraints, etc. The types that determine attribute restraints (column restraints) are just like how a struct or record has sub fields with more type specifications per each struct or record field.
No, a relvar is an instance of a variable. A variable may possess a type which constrains the values it may contain, but a variable is not a type.

{Well it is a 'rel'var, not just any old 'var'. That implies it is named at the top level of a relational database, and that it names a mutable relation (if not mutable, not really a 'variable'). I would note that relation does not equal table... except in practice. Tables can't be infinite. Relations - subsets of cartesian products of potentially infinite domains - certainly can be.}

It is, in fact, "any old 'var'" that happens to contain a value which is a relation, and which is often but not necessarily persistent, as a relvar (short for "relation-valued variable" or "relation variable") may be temporary or local. A relvar is not necessarily at the top level of a relational database (i.e., it may be a local relvar), though the top level of a relational database consists of persistent relvars. Variables are named, relations are not. See RdbRelVar. By the way, the cardinality of a relation held by a relvar is immaterial to the definition of "relvar".

{A 'var' that necessarily identifies a relation isn't just "any old 'var'" - the proof being trivial, that I can point at a 'var' at random (e.g. one identifying an 'int') and it isn't a relvar. As far as the 'naming' goes, from my viewpoint variables never 'contain' values (values being immaterial and entirely un-containable). Variables do identify (or 'point at') and thereby give name to values - generally a temporally limited name based upon the lifetime of an object containing a representation of said value and an associated decodec. And I do know that the cardinality of a relation held by a relvar is immaterial to the definition of "relvar". That's why it would be a 'wrong answer' to say that a relvar has some sort of 'table type', because tables necessarily have finite cardinality, they being defined in terms of specifying exactly what they contain. A relvar identifies a relation, which could potentially have infinite cardinality, which is sufficient to say that it is not a 'table type'. (The statement to which you're responding was targeted originally at someone else rather than you, of course.)}

=========
http://infolab.stanford.edu/~ullman/fcdb/oracle/or-intro.html

=========
A table is a relation
  it aliases heading to columns

=========

I'm projecting on a relation (that's a join)

join = join(relation_a, relation_b)

projection(rename(relation_a.attribute("age"), "AGE"), relation_b.attribute("height"))

restriction(predicate)



a Table HAS A relation

relation
  heading
    attributes
===========

relation = heading(attributes) + tuples - it's the definition, not the content
  an attribute OF a relation
  you can *extend* a relation to have a new attribute

projection (select cols...)

restriction (where)

natural join (inner join)

intersection, difference, cartesian product (natural join w/o matching attrs.  special case of nat join), union

rename (table foo as far, column yyy as zzz)


"extend" a relation.
extend(foo * bar)
extend(max(foo))


the relation (name, age, weight)
the relation's projection over the attributes age, weight



produce a function that acts on a set and produces a result...

restriction(relation) => function

projection(relation) => function


...should be a delay before you plug in the actual data.  this is a specification.
  

(select) projection (from) relation (where) restriction
(select) projection (join) relation1, relation2 (where) restriction

as a matter of modeling, js prototypes might match up very well.


===============

The Relational algebra implemented via Prolog rules and queries.
Selection:

select( variables ) :- conditions on the constants. 
Constants select rows in the relation.
Intersection:

r_1in_r2( Vars ) :- r_1( Vars ), r2( Vars ). 
selects the entities that are in both r_1 and r2 (use the same variables).
Difference:

diff_r_1_r2( Vars ) :- r_1( Vars ), not r2( Vars ). 
selects the entities in r_1 that are not in r2.
Projection:

pr( variables ) :- r( variables and don't cares ). 
Don't cares represent columns to be deleted.
Cartesian product:

prod( variables ) :- r_1( vars ), r2( vars ). 
prod variables is the list of variables both in r_1 and r2.
Union: (two rules are required to perform union.)
union( variables ) :- first_relation( variables ). 
union( variables ) :- second_relation( variables ).

Natural Join: In the rule,
nat_join( variables shared variables ) :- 
    r_1(variables, shared variables), 
    r2(variables, shared variables).

the shared variables restrict search to common elements, reduced number of variables in the join eliminate multiple columns.



===================

Hmm.  Why is there specialization at the engine level, and the same specialization expressed in a different manner in the "algebra" classes?

e.g.

    def engine
      relation1.engine != relation2.engine ? Memory::Engine.new : relation1.engine
    end

    def table_sql(formatter = Sql::TableReference.new(self))
      relation1.externalize.table_sql(formatter)
    end

    def joins(environment, formatter = Sql::TableReference.new(environment))

seems suboptimal, sitting under the algebra folder.

also why is Arel::Array owned by/hardwired to memory engine?


maybe the engine should be a factory:

sessions = my_memory_engine.array(:session)
my_sql_engine.table(:user).join(my_memory_engine.table(:session)) => read
read.execute ==> result

...also you can just join in a raw array
my_sql_engine.table(:user).join([[1,'blue'],[2,'red'],[3,'green']]) => read
read.execute

? the joiner has to offer a couple of forms:
  - SqlStatement
  - Array

the joinee accepts one of them...?

or perhaps it's the joiner that makes the decision:
   Create a temporary (in-memory?) table with these rows.
   Then join using sql.
   Then continue, but clean up the temporary table when we're done.

*** more scenarios ***

===========

set up all the namespaces for a module in one place?

require("arel/attributes/namespace")

- unit tests on -x-straight v8-x-  >> no, just use node.  straight v8 is too bare.
- integration tests on memory engine

apply the same integration suite everywhere?  possible?
 
sql engine
- integration tests that run on node-sqlite (i.e. incorporating node)
- then take those same integration tests and reuse on html5 client side db 
    (in-browser tests [html pages]?  
       what about headless safari?  "run if darwin"  could just be loading an html page and scraping the results, printing to command line (could even poll and puts...use ruby).  use a plain-text jasmine runner.  extract this?)


generate a minified arel-all-minified.js?

idea: jasmine plain-text html runner, plus rubycocoa safari stuff from schnauzer =
  fast command-line browser-based js test run
  ...can the output be seen incrementally?
  target: unit test output looks exactly like command line output
    (failures look the same, etc).
  do it with macruby?


==========
Arel bugs:
  String likely does not convert false to "false"