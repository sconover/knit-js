Hmm.  Why is there specialization at the engine level, and the same specialization expressed in a different manner in the "algebra" classes?

e.g.

    def engine
      relation1.engine != relation2.engine ? Memory::Engine.new : relation1.engine
    end

    def table_sql(formatter = Sql::TableReference.new(self))
      relation1.externalize.table_sql(formatter)
    end

    def joins(environment, formatter = Sql::TableReference.new(environment))

seems suboptimal, sitting under the algebra folder.

also why is Arel::Array owned by/hardwired to memory engine?


maybe the engine should be a factory:

sessions = my_memory_engine.array(:session)
my_sql_engine.table(:user).join(my_memory_engine.table(:session)) => read
read.execute ==> result

...also you can just join in a raw array
my_sql_engine.table(:user).join([[1,'blue'],[2,'red'],[3,'green']]) => read
read.execute

? the joiner has to offer a couple of forms:
  - SqlStatement
  - Array

the joinee accepts one of them...?

or perhaps it's the joiner that makes the decision:
   Create a temporary (in-memory?) table with these rows.
   Then join using sql.
   Then continue, but clean up the temporary table when we're done.

*** more scenarios ***

===========

set up all the namespaces for a module in one place?

require("arel/attributes/namespace")

- unit tests on -x-straight v8-x-  >> no, just use node.  straight v8 is too bare.
- integration tests on memory engine

apply the same integration suite everywhere?  possible?
 
sql engine
- integration tests that run on node-sqlite (i.e. incorporating node)
- then take those same integration tests and reuse on html5 client side db 
    (in-browser tests [html pages]?  
       what about headless safari?  "run if darwin"  could just be loading an html page and scraping the results, printing to command line (could even poll and puts...use ruby).  use a plain-text jasmine runner.  extract this?)


generate a minified arel-all-minified.js?

idea: jasmine plain-text html runner, plus rubycocoa safari stuff from schnauzer =
  fast command-line browser-based js test run
  ...can the output be seen incrementally?
  target: unit test output looks exactly like command line output
    (failures look the same, etc).
  do it with macruby?


==========
Arel bugs:
  String likely does not convert false to "false"