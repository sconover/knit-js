...you're replacing one of the relations in the join with one that's now wrapped differently

selection pushing:

join.relationOne = select(join.relationOne, predicate)
remove outer select

so you're lopping off parts of the predicate.

select with no predicate just returns the inner relation


pushing on to the join:

join.cross = predicate
remove outer select



6. 1. 3. Selection and cross product
Cross product is the costliest operator to evaluate. If the input relations have N and M rows, the result will contain  rows. Therefore it is very important to do our best to decrease the size of both operands before applying the cross product operator.

This can be effectively done, if the cross product is followed by a selection operator, e.g. (R × P). Considering the definition of join, this is the most likely case. If the cross product is not followed by a selection operator, we can try to push down a selection from higher levels of the expression tree using the other selection rules.

In the above case we break up condition A into conditions B, C and D using the split rules about complex selection conditions, so that A = B  C  D and B only contains attributes from R, C contains attributes only from P and D contains the part of A that contains attributes from both R and P. Note, that B, C or D are possibly empty. Then the following holds:



=========

- do math
  - selection, projection pushing
  - conjunction splitting, etc
 http://en.wikipedia.org/wiki/Relational_algebra#Use_of_algebraic_properties_for_query_optimization
- then make questions work
  - isNaturalJoin()
- redo the object model
  - class "style"
  - mixins
  - should I go to a functional style by default?
    ra.project(ra.select(r, somePredicate), [name, age])
- unit test - memory equals, selection, projection, cartesian join (simple tests)


===========

Breaking up selections with complex conditions

A selection whose condition is a conjunction of simpler conditions is equivalent to a sequence of selections with those same individual conditions, and selection whose condition is a disjunction is equivalent to a union of selections. These identities can be used to merge selections so that fewer selections need to be evaluated, or to split them so that the component selections may be moved or optimized separately.



This can be effectively done, if the cross product is followed by a selection operator, e.g. σA(R × P). Considering the definition of join, this is the most likely case. If the cross product is not followed by a selection operator, we can try to push down a selection from higher levels of the expression tree using the other selection rules.

============

grand unification

- good_question is really about a couple of things:  (-rb first)
  - basic http request validation and parsing
  - constructing and validating a relation (e.g. relation-rb)

- predicated becomes extensions in relation-rb, around the relation-rb predicate model  (-rb first)
  - port that stuff to js?

- validation/constraints on a relation (-rb first)
  - constraint on join magnitude
    - "this relation may not participate in a join in which more than 1000 tuples are used"

- prove out various engines using a common set of acceptance tests defined in json  (-js first)
  - relation-acceptance project.  notes plus json.

- should all relation projects have a possible async style?
  - what do you do in ruby?  em or something?
  - http://www.igvita.com/2008/09/05/asynchronous-database-access-in-ruby/
  - http://github.com/tmm1/em-mysql
  - http://www.espace.com.eg/neverblock/blog/2008/09/04/neverblock-instant-scaling-for-your-rails-apps/
  - http://www.espace.com.eg/neverblock/blog/2008/08/28/neverblock-mysql-support/

========

inputs and outputs are tuples, expressed as arrays.

...so we need to insert


Async by default
  what parts should be async?  tuples() ?  anything else?

insert, update, delete ...come back with what?  boolean?


GOAL: you can learn about relational algebra by reading the code.
  ...so things like Rename being duck-typed to relation might be weird...
GOAL: DSL for naturally expressing a statement


inner join: "The result of the join can be defined as the outcome of first taking the Cartesian product (or cross-join) of all records in the tables (combining every record in table A with every record in table B)—then return all records which satisfy the join predicate."


- an equi join is a theta join that only allows equality compairsons in the join predicate
  (sql "using" - though undoubtedly this is the kind of thing where specific
   dbms's will want to accomplish this different ways)
- a natural join is an equi join that joins on all identical attributes

later:
  allow join strategies (at least on inner join)
    - hash merge
    - sort merge
    ...this applies to in-memory cases only
   calculate the "expense" of a join (carindality) - expose this, 
     use this value to acceptance-test the join strategy


Set operations.  They do something to a relation, and yield a relation.
	General set operations:
	sort, set difference, intersection, union
	  
	  should be a mixin.

	Set operations specialized for RA:
	projection, selection(restriction), join

=========
r l a js

ra

=========
DSL ideas

OO style / functional style

r2 = person.project("name", "age") / r2 = project(person, "name", "age")

r2 = person
  .join(house)
    .on("house_id", "id")
  .end 
/ 
r2 = join(person, "house_id", house, "id")

r2 = sort(person, ["name",ASC])


engine.relation("person").join(engine.relation("house"))

person
  .join(house)
    .on("house_id", "id")
  .end 


=========

noun / verb

relation
  attributes, aka heading
  attribute, aka domain

rename (relation / attribute)

projection / project
join / join
selection / select  , alias restriction / restrict

union / union
intersection / intersect
difference / diff




=========

t * t2 [foo = bar]

t * t2 ()

=========

http://c2.com/cgi/wiki?NotesOnaCeePlusPlusRdbmsApi

  void PrintEmployeeProjectManagers?(CDatabase& db)
  {
	CTupleList tl(db["Employees"]
		  .Join("Projects")
		  .Join(db["Employees"]
			.Rename("ID", "ManagerID")
			.Rename("Name", "ManagerName?"))
		  .DropAllBut?(attr("Name") | attr("ManagerName?")));
	for (CTupleList::iterator i = tl.begin(); i != tl.end(); ++i)
	std::cout << (*i)["Name"] << "  " << (*i)["ManagerName?"] << std::endl;
  }




=========
[topical!]

http://c2.com/cgi/wiki?RelationalLanguage

It is sad to see SQL being the only widespread data language, as it really adds a lot of mess to the relatively clean conceptual model of relational algebra. The strength of the relational model is its enormously simple data model: in addition to data types (ints, strings, etc.), it only has relations, operators (projection, selection, join, union, sorting, and some others) and integrity constraints.

It would be great to be able to use, in production code, a language where one could say 't' instead of 'select * from t' and 't * t2 [foo = bar]' instead of 'select * from t join t2 on foo=bar'.

In practice since very few would use a multiplication without a filter, I believe they should be combined into a single operator (join). (We can still keep multiplication.) Further, a functional style would be nice so that DBA's could more easily define their own operators without having to add new syntax. A new function that uses two existing functions is not new syntax, just a new function.


=========

from: http://c2.com/cgi/wiki?DatabaseType

I just realized recently that a RelVar is actually an instance of a DatabaseType (or, maybe more specifically, a Table Type)... for example, all variables are instances of a type (for those who think in types). So in fact a relvar is really an instance of some sort of grander type.. or RelType?. The specifications of the RelType? or DatabaseType are the schema, the constraints, etc. The types that determine attribute restraints (column restraints) are just like how a struct or record has sub fields with more type specifications per each struct or record field.
No, a relvar is an instance of a variable. A variable may possess a type which constrains the values it may contain, but a variable is not a type.

{Well it is a 'rel'var, not just any old 'var'. That implies it is named at the top level of a relational database, and that it names a mutable relation (if not mutable, not really a 'variable'). I would note that relation does not equal table... except in practice. Tables can't be infinite. Relations - subsets of cartesian products of potentially infinite domains - certainly can be.}

It is, in fact, "any old 'var'" that happens to contain a value which is a relation, and which is often but not necessarily persistent, as a relvar (short for "relation-valued variable" or "relation variable") may be temporary or local. A relvar is not necessarily at the top level of a relational database (i.e., it may be a local relvar), though the top level of a relational database consists of persistent relvars. Variables are named, relations are not. See RdbRelVar. By the way, the cardinality of a relation held by a relvar is immaterial to the definition of "relvar".

{A 'var' that necessarily identifies a relation isn't just "any old 'var'" - the proof being trivial, that I can point at a 'var' at random (e.g. one identifying an 'int') and it isn't a relvar. As far as the 'naming' goes, from my viewpoint variables never 'contain' values (values being immaterial and entirely un-containable). Variables do identify (or 'point at') and thereby give name to values - generally a temporally limited name based upon the lifetime of an object containing a representation of said value and an associated decodec. And I do know that the cardinality of a relation held by a relvar is immaterial to the definition of "relvar". That's why it would be a 'wrong answer' to say that a relvar has some sort of 'table type', because tables necessarily have finite cardinality, they being defined in terms of specifying exactly what they contain. A relvar identifies a relation, which could potentially have infinite cardinality, which is sufficient to say that it is not a 'table type'. (The statement to which you're responding was targeted originally at someone else rather than you, of course.)}

=========

http://www.cs.rochester.edu/~nelson/courses/csc_173/relations/algebra.html

http://infolab.stanford.edu/~ullman/fcdb/oracle/or-intro.html

=========
A table is a relation
  it aliases heading to columns

=========

I'm projecting on a relation (that's a join)

join = join(relation_a, relation_b)

projection(rename(relation_a.attribute("age"), "AGE"), relation_b.attribute("height"))

selection(predicate)  #aka restriction



relation
  heading
    attributes
===========

relation = heading(attributes) + tuples - it's the definition, not the content
  an attribute OF a relation
  you can *extend* a relation to have a new attribute

projection (select cols...)

selection (where) #aka restriction

natural join (inner join)

intersection, difference, cartesian product (natural join w/o matching attrs.  special case of nat join), union

rename (table foo as far, column yyy as zzz)


"extend" a relation.
extend(foo * bar)
extend(max(foo))


the relation (name, age, weight)
the relation's projection over the attributes age, weight



produce a function that acts on a set and produces a result...

selection(relation) => function  #aka restriction

projection(relation) => function


...should be a delay before you plug in the actual data.  this is a specification.
  

(select) projection (from) relation (where) selection #aka restriction
(select) projection (join) relation1, relation2 (where) selection

as a matter of modeling, js prototypes might match up very well.


===============

The Relational algebra implemented via Prolog rules and queries.
Selection:

select( variables ) :- conditions on the constants. 
Constants select rows in the relation.
Intersection:

r_1in_r2( Vars ) :- r_1( Vars ), r2( Vars ). 
selects the entities that are in both r_1 and r2 (use the same variables).
Difference:

diff_r_1_r2( Vars ) :- r_1( Vars ), not r2( Vars ). 
selects the entities in r_1 that are not in r2.
Projection:

pr( variables ) :- r( variables and don't cares ). 
Don't cares represent columns to be deleted.
Cartesian product:

prod( variables ) :- r_1( vars ), r2( vars ). 
prod variables is the list of variables both in r_1 and r2.
Union: (two rules are required to perform union.)
union( variables ) :- first_relation( variables ). 
union( variables ) :- second_relation( variables ).

Natural Join: In the rule,
nat_join( variables shared variables ) :- 
    r_1(variables, shared variables), 
    r2(variables, shared variables).

the shared variables restrict search to common elements, reduced number of variables in the join eliminate multiple columns.



===================

Hmm.  Why is there specialization at the engine level, and the same specialization expressed in a different manner in the "algebra" classes?

e.g.

    def engine
      relation1.engine != relation2.engine ? Memory::Engine.new : relation1.engine
    end

    def table_sql(formatter = Sql::TableReference.new(self))
      relation1.externalize.table_sql(formatter)
    end

    def joins(environment, formatter = Sql::TableReference.new(environment))

seems suboptimal, sitting under the algebra folder.

also why is Arel::Array owned by/hardwired to memory engine?


maybe the engine should be a factory:

sessions = my_memory_engine.array(:session)
my_sql_engine.table(:user).join(my_memory_engine.table(:session)) => read
read.execute ==> result

...also you can just join in a raw array
my_sql_engine.table(:user).join([[1,'blue'],[2,'red'],[3,'green']]) => read
read.execute

? the joiner has to offer a couple of forms:
  - SqlStatement
  - Array

the joinee accepts one of them...?

or perhaps it's the joiner that makes the decision:
   Create a temporary (in-memory?) table with these rows.
   Then join using sql.
   Then continue, but clean up the temporary table when we're done.

*** more scenarios ***

===========

set up all the namespaces for a module in one place?

require("arel/attributes/namespace")

- unit tests on -x-straight v8-x-  >> no, just use node.  straight v8 is too bare.
- integration tests on memory engine

apply the same integration suite everywhere?  possible?
 
sql engine
- integration tests that run on node-sqlite (i.e. incorporating node)
- then take those same integration tests and reuse on html5 client side db 
    (in-browser tests [html pages]?  
       what about headless safari?  "run if darwin"  could just be loading an html page and scraping the results, printing to command line (could even poll and puts...use ruby).  use a plain-text jasmine runner.  extract this?)


generate a minified arel-all-minified.js?

idea: jasmine plain-text html runner, plus rubycocoa safari stuff from schnauzer =
  fast command-line browser-based js test run
  ...can the output be seen incrementally?
  target: unit test output looks exactly like command line output
    (failures look the same, etc).
  do it with macruby?


==========
Arel bugs:
  String likely does not convert false to "false"