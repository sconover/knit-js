Should be able to prove out various engines using a common set of acceptance tests

inputs and outputs are tuples, expressed as arrays.

...so we need to insert


Async by default
  what parts should be async?  tuples() ?  anything else?


=========
http://infolab.stanford.edu/~ullman/fcdb/oracle/or-intro.html

=========
A table is a relation
  it aliases heading to columns

=========

I'm projecting on a relation (that's a join)

join = join(relation_a, relation_b)

projection(rename(relation_a.attribute("age"), "AGE"), relation_b.attribute("height"))

restriction(predicate)



a Table HAS A relation

relation
  heading
    attributes
===========

relation = heading(attributes) + tuples - it's the definition, not the content
  an attribute OF a relation
  you can *extend* a relation to have a new attribute

projection (select cols...)

restriction (where)

natural join (inner join)

intersection, difference, cartesian product (natural join w/o matching attrs.  special case of nat join), union

rename (table foo as far, column yyy as zzz)


"extend" a relation.
extend(foo * bar)
extend(max(foo))


the relation (name, age, weight)
the relation's projection over the attributes age, weight



produce a function that acts on a set and produces a result...

restriction(relation) => function

projection(relation) => function


...should be a delay before you plug in the actual data.  this is a specification.
  

(select) projection (from) relation (where) restriction
(select) projection (join) relation1, relation2 (where) restriction

as a matter of modeling, js prototypes might match up very well.


===============

The Relational algebra implemented via Prolog rules and queries.
Selection:

select( variables ) :- conditions on the constants. 
Constants select rows in the relation.
Intersection:

r_1in_r2( Vars ) :- r_1( Vars ), r2( Vars ). 
selects the entities that are in both r_1 and r2 (use the same variables).
Difference:

diff_r_1_r2( Vars ) :- r_1( Vars ), not r2( Vars ). 
selects the entities in r_1 that are not in r2.
Projection:

pr( variables ) :- r( variables and don't cares ). 
Don't cares represent columns to be deleted.
Cartesian product:

prod( variables ) :- r_1( vars ), r2( vars ). 
prod variables is the list of variables both in r_1 and r2.
Union: (two rules are required to perform union.)
union( variables ) :- first_relation( variables ). 
union( variables ) :- second_relation( variables ).

Natural Join: In the rule,
nat_join( variables shared variables ) :- 
    r_1(variables, shared variables), 
    r2(variables, shared variables).

the shared variables restrict search to common elements, reduced number of variables in the join eliminate multiple columns.



===================

Hmm.  Why is there specialization at the engine level, and the same specialization expressed in a different manner in the "algebra" classes?

e.g.

    def engine
      relation1.engine != relation2.engine ? Memory::Engine.new : relation1.engine
    end

    def table_sql(formatter = Sql::TableReference.new(self))
      relation1.externalize.table_sql(formatter)
    end

    def joins(environment, formatter = Sql::TableReference.new(environment))

seems suboptimal, sitting under the algebra folder.

also why is Arel::Array owned by/hardwired to memory engine?


maybe the engine should be a factory:

sessions = my_memory_engine.array(:session)
my_sql_engine.table(:user).join(my_memory_engine.table(:session)) => read
read.execute ==> result

...also you can just join in a raw array
my_sql_engine.table(:user).join([[1,'blue'],[2,'red'],[3,'green']]) => read
read.execute

? the joiner has to offer a couple of forms:
  - SqlStatement
  - Array

the joinee accepts one of them...?

or perhaps it's the joiner that makes the decision:
   Create a temporary (in-memory?) table with these rows.
   Then join using sql.
   Then continue, but clean up the temporary table when we're done.

*** more scenarios ***

===========

set up all the namespaces for a module in one place?

require("arel/attributes/namespace")

- unit tests on -x-straight v8-x-  >> no, just use node.  straight v8 is too bare.
- integration tests on memory engine

apply the same integration suite everywhere?  possible?
 
sql engine
- integration tests that run on node-sqlite (i.e. incorporating node)
- then take those same integration tests and reuse on html5 client side db 
    (in-browser tests [html pages]?  
       what about headless safari?  "run if darwin"  could just be loading an html page and scraping the results, printing to command line (could even poll and puts...use ruby).  use a plain-text jasmine runner.  extract this?)


generate a minified arel-all-minified.js?

idea: jasmine plain-text html runner, plus rubycocoa safari stuff from schnauzer =
  fast command-line browser-based js test run
  ...can the output be seen incrementally?
  target: unit test output looks exactly like command line output
    (failures look the same, etc).
  do it with macruby?


==========
Arel bugs:
  String likely does not convert false to "false"